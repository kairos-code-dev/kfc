# 테스트 전략

## 개요

본 문서는 kotlin-krx 프로젝트의 포괄적인 테스트 전략을 제공합니다. 단위 테스트, 통합 테스트, 성능 테스트를 포함하며, 실제 KRX API와의 통합 및 엣지 케이스 처리를 검증합니다.

**목표 커버리지**: > 80%

---

## 테스트 철학

### Fake > Mock

kotlin-krx 프로젝트는 **Fake 구현을 우선**하여 사용합니다:

**Fake를 사용하는 이유**:
1. **실제 동작에 가까움**: 인터페이스를 실제로 구현하여 더 현실적인 테스트
2. **리팩토링 안전성**: Mock 라이브러리 문법에 의존하지 않아 코드 변경에 강함
3. **가독성**: Mock 설정 코드보다 이해하기 쉬운 일반 Kotlin 코드
4. **재사용성**: 여러 테스트에서 Fake 구현을 공유 가능
5. **의존성 최소화**: MockK 같은 외부 라이브러리 불필요

**Fake 구현 원칙**:
- 실제 인터페이스를 구현
- 테스트에 필요한 최소한의 기능만 제공
- 상태를 저장하여 실제 동작 시뮬레이션
- 명확한 이름 사용 (Fake prefix)

**예시**:
```kotlin
// ✅ Good: Fake 사용
class FakeKrxClient : KrxClient {
    private val responses = mutableMapOf<String, Map<String, Any?>>()

    fun setResponse(bld: String, response: Map<String, Any?>) {
        responses[bld] = response
    }

    override fun post(bld: String, params: Map<String, String>): Map<String, Any?> {
        return responses[bld] ?: emptyMap()
    }
}

// ❌ Avoid: Mock 사용
val mockClient = mockk<KrxClient>()
every { mockClient.post(any(), any()) } returns mockResponse
```

**Mock 사용 시점** (필요한 경우에만):
- 외부 시스템과의 복잡한 상호작용 검증
- Fake 구현이 너무 복잡해지는 경우
- 특정 예외 상황 테스트

---

## 테스트 계층

```
┌──────────────────────────────────────────────────────────────┐
│                     E2E 테스트 (선택적)                      │
│              전체 워크플로우 검증                            │
└────────────────────────┬─────────────────────────────────────┘
                         │
┌────────────────────────▼─────────────────────────────────────┐
│                    통합 테스트 (Integration)                 │
│         실제 KRX API 호출, 전체 흐름 검증                   │
│    - Mdcstat04701IntegrationTest                            │
│    - EtfServiceIntegrationTest                              │
└────────────────────────┬─────────────────────────────────────┘
                         │
┌────────────────────────▼─────────────────────────────────────┐
│                    단위 테스트 (Unit)                        │
│         개별 함수/메서드 검증, Fake 사용 (필요시)            │
│    - NormalizationExtensionsTest                            │
│    - ComprehensiveEtfInfoTest                               │
│    - EtfComprehensiveServiceTest                            │
└──────────────────────────────────────────────────────────────┘
```

---

## 테스트 데이터 선정

### 대표 ETF 목록

**KOSPI 200 추종 (3개)**:
- `069500` - KODEX 200
- `102110` - TIGER 200
- `152100` - ARIRANG 200

**섹터별 (6개)**:
- `091180` - KODEX 반도체 (IT)
- `117460` - TIGER 2차전지테마 (산업재)
- `130680` - KODEX 단기채권 (채권)
- `132030` - KODEX 골드선물 (H) (상품)
- `261240` - KODEX 미국S&P500선물(H) (해외)
- `251350` - KODEX 코스닥150레버리지 (레버리지)

**엣지 케이스용 (3개)**:
- 신규 상장 ETF (짧은 히스토리)
- 거래량 극소 ETF
- 레버리지/인버스 ETF

---

### 테스트 날짜

**정상 거래일**:
- `2024-01-02` (연초 첫 거래일)
- `2024-06-03` (중간 날짜)
- 최근 거래일 (동적)

**엣지 케이스 날짜**:
- `2024-01-01` (공휴일 - 신정)
- `2024-02-10` (토요일)
- `2023-12-25` (크리스마스)

---

## 단위 테스트

### 1. 정규화 함수 테스트

**파일**: `/app/src/test/kotlin/com/kairos/krx/util/NormalizationExtensionsTest.kt`

```kotlin
package com.kairos.krx.util

import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.CsvSource
import java.math.BigDecimal
import java.time.LocalDate

@DisplayName("정규화 확장 함수 테스트")
class NormalizationExtensionsTest {

    @Nested
    @DisplayName("toKrxPrice() 테스트")
    inner class ToKrxPriceTest {

        @ParameterizedTest
        @CsvSource(
            "42965, 42965.00",
            "'42,965', 42965.00",
            "'1,080', 1080.00",
            "'-', 0.00",
            "'', 0.00",
            "'  ', 0.00"
        )
        fun `정상 값 변환`(input: String, expected: String) {
            assertEquals(BigDecimal(expected), input.toKrxPrice())
        }

        @Test
        fun `음수 값 처리`() {
            assertEquals(BigDecimal("-1080.00"), "-1080".toKrxPrice())
            assertEquals(BigDecimal("-1080.00"), "-1,080".toKrxPrice())
        }

        @Test
        fun `잘못된 형식 처리`() {
            assertEquals(BigDecimal.ZERO, "abc".toKrxPrice())
            assertEquals(BigDecimal.ZERO, "N/A".toKrxPrice())
        }
    }

    @Nested
    @DisplayName("toKrxAmount() 테스트")
    inner class ToKrxAmountTest {

        @ParameterizedTest
        @CsvSource(
            "'850,707,000,000', 850707000000",
            "'19,800,000', 19800000",
            "'-', 0",
            "'', 0"
        )
        fun `대용량 값 변환`(input: String, expected: String) {
            assertEquals(BigDecimal(expected), input.toKrxAmount())
        }
    }

    @Nested
    @DisplayName("toKrxSignedLong() 테스트")
    inner class ToKrxSignedLongTest {

        @Test
        fun `양수 값`() {
            assertEquals(1234567L, "1,234,567".toKrxSignedLong())
        }

        @Test
        fun `음수 값 유지`() {
            assertEquals(-1234567L, "-1,234,567".toKrxSignedLong())
        }

        @Test
        fun `특수 값`() {
            assertEquals(0L, "-".toKrxSignedLong())
            assertEquals(0L, "".toKrxSignedLong())
        }
    }

    @Nested
    @DisplayName("toKrxRate() 테스트")
    inner class ToKrxRateTest {

        @Test
        fun `소수점 값`() {
            assertEquals(BigDecimal("2.5800"), "2.58".toKrxRate())
            assertEquals(BigDecimal("-1.2300"), "-1.23".toKrxRate())
        }

        @Test
        fun `특수 값`() {
            assertEquals(BigDecimal.ZERO, "-".toKrxRate())
            assertEquals(BigDecimal.ZERO, "".toKrxRate())
        }
    }

    @Nested
    @DisplayName("toKrxBigDecimal() 테스트")
    inner class ToKrxBigDecimalTest {

        @Test
        fun `고정밀 값`() {
            assertEquals(
                BigDecimal("43079.14"),
                "43,079.14".toKrxBigDecimal()
            )
        }

        @Test
        fun `보수율 정확도`() {
            assertEquals(
                BigDecimal("0.15"),
                "0.15".toKrxBigDecimal()
            )
        }
    }

    @Nested
    @DisplayName("toKrxDate() 테스트")
    inner class ToKrxDateTest {

        @Test
        fun `Slash 형식 파싱`() {
            assertEquals(
                LocalDate.of(2024, 1, 2),
                "2024/01/02".toKrxDate()
            )
        }

        @Test
        fun `Compact 형식 파싱`() {
            assertEquals(
                LocalDate.of(2024, 1, 2),
                "20240102".toKrxDate()
            )
        }

        @Test
        fun `특수 값 처리`() {
            assertEquals(LocalDate.MIN, "-".toKrxDate())
            assertEquals(LocalDate.MIN, "".toKrxDate())
        }

        @Test
        fun `잘못된 날짜 처리`() {
            assertEquals(LocalDate.MIN, "2024-01-02".toKrxDate())  // 대시 형식
            assertEquals(LocalDate.MIN, "invalid".toKrxDate())
        }
    }

    @Nested
    @DisplayName("toKrxDirection() 테스트")
    inner class ToKrxDirectionTest {

        @Test
        fun `등락 구분 변환`() {
            assertEquals(Direction.UP, "1".toKrxDirection())
            assertEquals(Direction.DOWN, "2".toKrxDirection())
            assertEquals(Direction.UNCHANGED, "3".toKrxDirection())
            assertEquals(Direction.UNCHANGED, "".toKrxDirection())
        }
    }
}
```

---

### 2. 모델 클래스 테스트

**파일**: `/app/src/test/kotlin/com/kairos/krx/model/ComprehensiveEtfInfoTest.kt`

```kotlin
package com.kairos.krx.model

import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import java.math.BigDecimal
import java.time.LocalDate

class ComprehensiveEtfInfoTest {

    @Test
    fun `fromRaw() 정상 동작`() {
        val raw = mapOf(
            "TRD_DD" to "2024/01/02",
            "ISU_CD" to "KR7152100004",
            "ISU_SRT_CD" to "152100",
            "ISU_ABBRV" to "ARIRANG 200",
            "TDD_CLSPRC" to "42,965",
            "LST_NAV" to "43,079.14",
            "ETF_TOT_FEE" to "0.15",
            "WK52_HGPR" to "45,230",
            "WK52_LWPR" to "38,125",
            // ... 나머지 필드
        )

        val info = ComprehensiveEtfInfo.fromRaw(raw)

        assertEquals("152100", info.ticker)
        assertEquals(BigDecimal("42965.00"), info.closePrice)
        assertEquals(BigDecimal("43079.14"), info.nav)
        assertEquals(BigDecimal("0.1500"), info.totalFee)
    }

    @Test
    fun `isNear52WeekHigh() 정상 동작`() {
        val info = createTestInfo(
            closePrice = BigDecimal("45000.00"),
            week52High = BigDecimal("45230.00")
        )
        assertTrue(info.isNear52WeekHigh())

        val info2 = createTestInfo(
            closePrice = BigDecimal("40000.00"),
            week52High = BigDecimal("45230.00")
        )
        assertFalse(info2.isNear52WeekHigh())
    }

    @Test
    fun `hasLowFee() 정상 동작`() {
        val info = createTestInfo(totalFee = BigDecimal("0.1500"))
        assertTrue(info.hasLowFee())

        val info2 = createTestInfo(totalFee = BigDecimal("0.5000"))
        assertFalse(info2.hasLowFee())
    }

    private fun createTestInfo(
        closePrice: BigDecimal = BigDecimal("42965.00"),
        week52High: BigDecimal = BigDecimal("45230.00"),
        totalFee: BigDecimal = BigDecimal("0.1500")
    ): ComprehensiveEtfInfo {
        return ComprehensiveEtfInfo(
            tradeDate = LocalDate.of(2024, 1, 2),
            ticker = "152100",
            closePrice = closePrice,
            week52High = week52High,
            totalFee = totalFee,
            // ... 나머지 필드 (기본값)
        )
    }
}
```

---

### 3. 서비스 단위 테스트 (Fake 사용)

**파일**: `/app/src/test/kotlin/com/kairos/krx/etx/EtfComprehensiveServiceTest.kt`

```kotlin
package com.kairos.krx.etx

import com.kairos.krx.client.KrxClient
import com.kairos.krx.ticker.EtxTickerCache
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import java.math.BigDecimal

/**
 * Fake KrxClient 구현
 * 실제 HTTP 호출 없이 미리 정의된 응답 반환
 */
class FakeKrxClient : KrxClient {
    private val responses = mutableMapOf<String, Map<String, Any?>>()

    fun setResponse(bld: String, response: Map<String, Any?>) {
        responses[bld] = response
    }

    override fun post(bld: String, params: Map<String, String>): Map<String, Any?> {
        return responses[bld]
            ?: throw IllegalStateException("No fake response for BLD: $bld")
    }
}

/**
 * Fake EtxTickerCache 구현
 * 실제 API 호출 없이 테스트 데이터 반환
 */
class FakeEtxTickerCache : EtxTickerCache {
    private val tickers = mutableMapOf<String, EtxTickerInfo>()

    fun addTicker(ticker: String, isin: String, name: String) {
        tickers[ticker] = EtxTickerInfo(ticker, isin, name)
    }

    override fun getIsin(ticker: String): String? {
        return tickers[ticker]?.isin
    }

    override fun getName(ticker: String): String? {
        return tickers[ticker]?.name
    }
}

@DisplayName("ETF 종합정보 서비스 테스트 (Fake 사용)")
class EtfComprehensiveServiceTest {

    private lateinit var fakeClient: FakeKrxClient
    private lateinit var fakeTickerCache: FakeEtxTickerCache
    private lateinit var service: EtfComprehensiveService

    @BeforeEach
    fun setup() {
        fakeClient = FakeKrxClient()
        fakeTickerCache = FakeEtxTickerCache()
        service = EtfComprehensiveService(fakeClient, fakeTickerCache)

        // 테스트 데이터 설정
        fakeTickerCache.addTicker("069500", "KR7069500007", "KODEX 200")
    }

    @Test
    fun `종합 정보 조회 성공`() {
        // Given: Fake 응답 설정
        fakeClient.setResponse(
            "dbms/MDC/STAT/standard/MDCSTAT04701",
            createFakeEtfResponse(
                ticker = "069500",
                name = "KODEX 200",
                closePrice = "42,965",
                nav = "43,079.14",
                marketCap = "850,707,000,000"
            )
        )

        // When: 서비스 호출
        val result = service.getComprehensiveInfo("069500", "20240102")

        // Then: 검증
        assertNotNull(result)
        assertEquals("069500", result.ticker)
        assertEquals("KODEX 200", result.name)
        assertEquals(BigDecimal("42965.00"), result.closePrice)
        assertEquals(BigDecimal("43079.14"), result.nav)
        assertEquals(BigDecimal("850707000000"), result.marketCap)
    }

    @Test
    fun `특수 값 처리 검증`() {
        // Given: "-" 및 빈 문자열 포함 응답
        fakeClient.setResponse(
            "dbms/MDC/STAT/standard/MDCSTAT04701",
            createFakeEtfResponse(
                ticker = "069500",
                name = "KODEX 200",
                closePrice = "-",        // 특수 값
                nav = "",                // 빈 문자열
                marketCap = "0"
            )
        )

        // When
        val result = service.getComprehensiveInfo("069500", "20240102")

        // Then: 특수 값이 0으로 변환되었는지 확인
        assertEquals(BigDecimal.ZERO, result.closePrice)
        assertEquals(BigDecimal.ZERO, result.nav)
        assertEquals(BigDecimal.ZERO, result.marketCap)
    }

    @Test
    fun `데이터 없음 처리`() {
        // Given: 빈 응답 설정
        fakeClient.setResponse(
            "dbms/MDC/STAT/standard/MDCSTAT04701",
            mapOf("output" to emptyList<Any>())
        )

        // When
        val result = service.getComprehensiveInfo("069500", "20240102")

        // Then
        assertNull(result)
    }

    @Test
    fun `저보수 ETF 필터링 동작`() {
        // Given
        fakeTickerCache.addTicker("152100", "KR7152100004", "ARIRANG 200")

        fakeClient.setResponse(
            "dbms/MDC/STAT/standard/MDCSTAT04701",
            createFakeEtfResponse(
                ticker = "152100",
                name = "ARIRANG 200",
                closePrice = "42,965",
                nav = "43,079.14",
                marketCap = "850,707,000,000",
                totalFee = "0.15"  // 저보수
            )
        )

        // When
        val lowFeeEtfs = service.getLowFeeEtfs(
            tickers = listOf("152100"),
            maxFee = BigDecimal("0.3")
        )

        // Then
        assertTrue(lowFeeEtfs.isNotEmpty())
        lowFeeEtfs.forEach { etf ->
            assertTrue(etf.totalFee <= BigDecimal("0.3000"))
        }
    }

    private fun createFakeEtfResponse(
        ticker: String,
        name: String,
        closePrice: String,
        nav: String,
        marketCap: String,
        totalFee: String = "0.15"
    ): Map<String, Any?> {
        return mapOf(
            "output" to listOf(
                mapOf(
                    "ISU_CD" to "KR7${ticker}007",
                    "ISU_ABBRV" to name,
                    "TDD_CLSPRC" to closePrice,
                    "LST_NAV" to nav,
                    "MKTCAP" to marketCap,
                    "ACC_TRDVOL" to "2,500,000",
                    "ACC_TRDVAL" to "107,412,500,000",
                    "ETF_TOT_FEE" to totalFee,
                    "WK52_HGST_PRC" to "45,000",
                    "WK52_LWST_PRC" to "38,000",
                    "IDX_ASST_CLSS_NM" to "주식",
                    "TRACE_IDX_NM" to "코스피 200"
                )
            )
        )
    }
}
```

---

## 통합 테스트

### 1. MDCSTAT04701 통합 테스트

**파일**: `/app/src/test/kotlin/com/kairos/krx/integration/Mdcstat04701IntegrationTest.kt`

```kotlin
package com.kairos.krx.integration

import com.kairos.krx.etx.EtfComprehensiveService
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.DisplayName
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import java.math.BigDecimal
import java.time.LocalDate

@SpringBootTest
@DisplayName("MDCSTAT04701 통합 테스트")
class Mdcstat04701IntegrationTest {

    @Autowired
    private lateinit var service: EtfComprehensiveService

    @Test
    @DisplayName("KODEX 200 종합 정보 조회")
    fun `KODEX 200 종합 정보 조회 성공`() {
        // Given
        val ticker = "069500"
        val date = LocalDate.of(2024, 1, 2)

        // When
        val info = service.getComprehensiveInfo(ticker, date)

        // Then
        assertNotNull(info, "응답이 null이 아니어야 함")
        assertEquals(ticker, info!!.ticker)
        assertEquals(date, info.tradeDate)

        // 가격 데이터 정합성
        assertTrue(info.closePrice > BigDecimal.ZERO, "종가는 양수")
        assertTrue(info.highPrice >= info.closePrice, "고가 >= 종가")
        assertTrue(info.lowPrice <= info.closePrice, "저가 <= 종가")

        // NAV 검증
        assertTrue(info.nav > BigDecimal.ZERO, "NAV는 양수")

        // 52주 고가/저가 검증 (핵심)
        assertTrue(info.week52High > BigDecimal.ZERO, "52주 고가는 양수")
        assertTrue(info.week52Low > BigDecimal.ZERO, "52주 저가는 양수")
        assertTrue(
            info.week52High >= info.closePrice,
            "52주 고가 >= 현재 종가"
        )
        assertTrue(
            info.week52Low <= info.closePrice,
            "52주 저가 <= 현재 종가"
        )

        // 총 보수 검증 (핵심)
        assertTrue(info.totalFee >= BigDecimal.ZERO, "총 보수는 0 이상")
        assertTrue(info.totalFee < BigDecimal("10.0000"), "총 보수는 10% 미만")

        // 자산군 검증
        assertNotNull(info.assetClass, "자산군은 null 아님")
        assertTrue(
            info.assetClass in listOf("주식", "채권", "상품", "파생", "혼합"),
            "유효한 자산군"
        )

        // 운용사 검증
        assertNotNull(info.assetManager, "운용사는 null 아님")
    }

    @Test
    @DisplayName("여러 ETF 동시 조회")
    fun `여러 ETF 동시 조회 성공`() {
        // Given
        val tickers = listOf("069500", "102110", "152100")  // KODEX, TIGER, ARIRANG
        val date = LocalDate.of(2024, 1, 2)

        // When
        val infos = service.getComprehensiveInfoMultiple(tickers, date)

        // Then
        assertEquals(tickers.size, infos.size, "모든 티커 조회 성공")
        tickers.forEach { ticker ->
            assertTrue(infos.containsKey(ticker), "$ticker 존재")
        }
    }

    @Test
    @DisplayName("저보수 ETF 필터링")
    fun `저보수 ETF 필터링 성공`() {
        // Given
        val tickers = listOf("069500", "102110", "152100")

        // When
        val lowFeeEtfs = service.getLowFeeEtfs(
            tickers = tickers,
            maxFee = BigDecimal("0.3")
        )

        // Then
        assertTrue(lowFeeEtfs.isNotEmpty(), "저보수 ETF 존재")
        lowFeeEtfs.forEach { etf ->
            assertTrue(etf.totalFee <= BigDecimal("0.3000"), "${etf.name} 보수: ${etf.totalFee}%")
        }
    }

    @Test
    @DisplayName("52주 고가 근처 ETF 필터링")
    fun `52주 고가 근처 ETF 필터링`() {
        // Given
        val tickers = listOf("069500", "102110", "152100")

        // When
        val nearHigh = service.getEtfsNear52WeekHigh(
            tickers = tickers,
            threshold = BigDecimal("0.95")
        )

        // Then
        nearHigh.forEach { etf ->
            val percentage = etf.closePrice
                .divide(etf.week52High, 4, RoundingMode.HALF_UP)
            assertTrue(percentage >= BigDecimal("0.95"), "${etf.name}: $percentage")
        }
    }

    @Test
    @DisplayName("휴일 날짜 오류 처리")
    fun `휴일 날짜는 빈 결과 반환`() {
        // Given
        val ticker = "069500"
        val holiday = LocalDate.of(2024, 1, 1)  // 신정

        // When
        val info = service.getComprehensiveInfo(ticker, holiday)

        // Then
        assertNull(info, "휴일에는 데이터 없음")
    }

    @Test
    @DisplayName("존재하지 않는 티커 오류 처리")
    fun `존재하지 않는 티커는 예외 발생`() {
        // Given
        val invalidTicker = "999999"

        // When & Then
        assertThrows<TickerNotFoundException> {
            service.getComprehensiveInfo(invalidTicker)
        }
    }
}
```

---

### 2. 역사적 데이터 통합 테스트

**파일**: `/app/src/test/kotlin/com/kairos/krx/integration/HistoricalDataIntegrationTest.kt`

```kotlin
package com.kairos.krx.integration

import com.kairos.krx.service.HistoricalDataService
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import java.time.LocalDate

@SpringBootTest
class HistoricalDataIntegrationTest {

    @Autowired
    private lateinit var service: HistoricalDataService

    @Test
    fun `1년 과거 데이터 조회`() {
        // Given
        val ticker = "069500"
        val from = LocalDate.now().minusYears(1)
        val to = LocalDate.now()

        // When
        val data = service.getHistoricalOhlcv(ticker, from, to)

        // Then
        assertTrue(data.isNotEmpty(), "데이터 존재")
        assertTrue(data.size >= 200, "최소 200개 거래일")  // 연간 약 250일
        assertEquals(data.first().date, data.minByOrNull { it.date }!!.date, "날짜 정렬")
    }

    @Test
    fun `자동 730일 분할 검증`() {
        // Given - 3년 데이터 (730일 초과)
        val ticker = "069500"
        val from = LocalDate.now().minusYears(3)
        val to = LocalDate.now()

        // When
        val data = service.getHistoricalOhlcv(ticker, from, to)

        // Then
        assertTrue(data.isNotEmpty())
        assertTrue(data.size >= 600, "3년치 데이터")
        // 중복 날짜 없음 확인
        val uniqueDates = data.map { it.date }.toSet()
        assertEquals(data.size, uniqueDates.size, "중복 날짜 없음")
    }

    @Test
    fun `상장일부터 조회 (from = null)`() {
        // Given
        val ticker = "069500"

        // When
        val data = service.getHistoricalOhlcv(
            ticker = ticker,
            from = null,  // 상장일 자동
            to = LocalDate.now()
        )

        // Then
        assertTrue(data.isNotEmpty())
        assertTrue(data.size > 1000, "장기 데이터")
    }
}
```

---

## 예상 엣지 케이스

### 1. 휴일 및 주말

**테스트 케이스**:
```kotlin
@Test
fun `주말 날짜는 빈 결과`() {
    val saturday = LocalDate.of(2024, 2, 10)
    val info = service.getComprehensiveInfo("069500", saturday)
    assertNull(info)
}

@Test
fun `공휴일은 빈 결과`() {
    val newYear = LocalDate.of(2024, 1, 1)
    val info = service.getComprehensiveInfo("069500", newYear)
    assertNull(info)
}
```

---

### 2. 신규 상장 ETF (짧은 히스토리)

**테스트 케이스**:
```kotlin
@Test
fun `신규 상장 ETF 조회`() {
    // 최근 상장 ETF 찾기
    val allEtfs = etfService.getAllBasicInfo()
    val recentlyListed = allEtfs.filter {
        it.listingDate.isAfter(LocalDate.now().minusMonths(6))
    }

    recentlyListed.forEach { etf ->
        val data = historicalService.getHistoricalOhlcv(
            ticker = etf.ticker,
            from = etf.listingDate,
            to = LocalDate.now()
        )

        assertTrue(data.isNotEmpty(), "${etf.name} 데이터 존재")
        assertEquals(etf.listingDate, data.first().date, "상장일부터 시작")
    }
}
```

---

### 3. 상장폐지 ETF

**테스트 케이스**:
```kotlin
@Test
fun `상장폐지 ETF 조회 실패`() {
    val delistedTicker = "999999"  // 가상의 상장폐지 티커

    assertThrows<TickerNotFoundException> {
        service.getComprehensiveInfo(delistedTicker)
    }
}
```

---

### 4. 730일 초과 날짜 범위

**테스트 케이스**:
```kotlin
@Test
fun `5년 데이터 자동 분할`() {
    val ticker = "069500"
    val from = LocalDate.now().minusYears(5)
    val to = LocalDate.now()

    val data = historicalService.getHistoricalOhlcv(ticker, from, to)

    // 5년치 데이터 (약 1250개 거래일)
    assertTrue(data.size > 1000)

    // 날짜 연속성 확인 (주말/공휴일 제외)
    data.zipWithNext().forEach { (prev, curr) ->
        val daysDiff = java.time.temporal.ChronoUnit.DAYS.between(prev.date, curr.date)
        assertTrue(daysDiff in 1..7, "날짜 간격 정상")
    }
}
```

---

### 5. 응답에 "-" 및 빈 값

**테스트 케이스**:
```kotlin
@Test
fun `특수 값 정규화 검증`() {
    // Fake 응답에 특수 값 포함
    val fakeResponse = mapOf(
        "TDD_CLSPRC" to "-",
        "ACC_TRDVAL" to "",
        "LST_NAV" to "43,079.14"
    )

    val closePrice = fakeResponse["TDD_CLSPRC"].toString().toKrxPrice()
    val tradingValue = fakeResponse["ACC_TRDVAL"].toString().toKrxAmount()

    assertEquals(BigDecimal.ZERO, closePrice, "'-' → 0")
    assertEquals(BigDecimal.ZERO, tradingValue, "빈 문자열 → 0")
}
```

---

## 테스트 유틸리티 및 헬퍼

### 1. FakeKrxClient

**목적**: 실제 HTTP 호출 없이 KRX API 응답 시뮬레이션

**특징**:
- 실제 KrxClient 인터페이스 구현
- 테스트별로 응답 데이터 설정 가능
- 실제 네트워크 호출 없이 빠른 테스트 실행
- 예측 가능하고 반복 가능한 테스트

**구현**:
```kotlin
class FakeKrxClient : KrxClient {
    private val responses = mutableMapOf<String, Map<String, Any?>>()

    fun setResponse(bld: String, response: Map<String, Any?>) {
        responses[bld] = response
    }

    override fun post(bld: String, params: Map<String, String>): Map<String, Any?> {
        return responses[bld]
            ?: throw IllegalStateException("No fake response for BLD: $bld")
    }

    // 편의 메서드: 미리 정의된 ETF 응답 생성
    fun setEtfResponse(ticker: String, date: String, data: EtfTestData) {
        setResponse(
            "dbms/MDC/STAT/standard/MDCSTAT04701",
            buildEtfResponse(ticker, date, data)
        )
    }
}
```

**사용 예제**:
```kotlin
@Test
fun `ETF 데이터 조회 테스트`() {
    val fakeClient = FakeKrxClient()
    fakeClient.setEtfResponse(
        ticker = "069500",
        date = "20240102",
        data = EtfTestData(
            closePrice = BigDecimal("42965.00"),
            nav = BigDecimal("43079.14")
        )
    )

    val service = EtfService(fakeClient)
    val result = service.getEtfData("069500", "20240102")

    assertEquals(BigDecimal("42965.00"), result.closePrice)
}
```

### 2. FakeTickerCache

**목적**: 티커 캐시 동작 시뮬레이션

```kotlin
class FakeEtxTickerCache : EtxTickerCache {
    private val tickers = mutableMapOf<String, TickerInfo>()

    fun addTicker(ticker: String, isin: String, name: String) {
        tickers[ticker] = TickerInfo(ticker, isin, name)
    }

    override fun getIsin(ticker: String): String? = tickers[ticker]?.isin
    override fun getName(ticker: String): String? = tickers[ticker]?.name
    override fun getAllTickers(): List<TickerInfo> = tickers.values.toList()
}
```

### 3. 테스트 데이터 빌더

**목적**: 복잡한 테스트 데이터 생성 간소화

```kotlin
data class EtfTestDataBuilder(
    var ticker: String = "069500",
    var name: String = "KODEX 200",
    var closePrice: BigDecimal = BigDecimal("42965.00"),
    var nav: BigDecimal = BigDecimal("43079.14"),
    var marketCap: BigDecimal = BigDecimal("850707000000")
) {
    fun build(): ComprehensiveEtfInfo {
        return ComprehensiveEtfInfo(
            ticker = ticker,
            name = name,
            closePrice = closePrice,
            nav = nav,
            marketCap = marketCap
            // ... other fields
        )
    }
}

// 사용 예제
val etfData = EtfTestDataBuilder()
    .apply {
        ticker = "102110"
        name = "TIGER 200"
    }
    .build()
```

---

### 4. Assertion 헬퍼

```kotlin
object EtfAssertions {

    fun assertValidOhlcv(ohlcv: Ohlcv) {
        assertTrue(ohlcv.high >= ohlcv.close, "고가 >= 종가")
        assertTrue(ohlcv.low <= ohlcv.close, "저가 <= 종가")
        assertTrue(ohlcv.high >= ohlcv.low, "고가 >= 저가")
        assertTrue(ohlcv.volume >= 0L, "거래량 >= 0")
    }

    fun assertValidComprehensiveInfo(info: ComprehensiveEtfInfo) {
        assertValidOhlcv(
            Ohlcv(
                info.tradeDate,
                info.openPrice,
                info.highPrice,
                info.lowPrice,
                info.closePrice,
                info.volume
            )
        )
        assertTrue(info.week52High >= info.closePrice, "52주 고가 >= 종가")
        assertTrue(info.week52Low <= info.closePrice, "52주 저가 <= 종가")
        assertTrue(info.totalFee >= BigDecimal.ZERO, "총 보수 >= 0")
    }
}
```

---

## 성능 테스트

### JMH 벤치마크

```kotlin
@State(Scope.Benchmark)
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MILLISECONDS)
class PerformanceBenchmark {

    private lateinit var service: HistoricalDataService

    @Setup
    fun setup() {
        service = // 초기화
    }

    @Benchmark
    fun measureSingleDateQuery() {
        service.getHistoricalOhlcv(
            ticker = "069500",
            from = LocalDate.of(2024, 1, 2),
            to = LocalDate.of(2024, 1, 2)
        )
    }

    @Benchmark
    fun measure730DayQuery() {
        service.getHistoricalOhlcv(
            ticker = "069500",
            from = LocalDate.now().minusDays(730),
            to = LocalDate.now()
        )
    }

    @Benchmark
    fun measure5YearQuery() {
        service.getHistoricalOhlcv(
            ticker = "069500",
            from = LocalDate.now().minusYears(5),
            to = LocalDate.now()
        )
    }
}
```

**성능 목표**:
- 단일 날짜: < 2초
- 730일: < 10초
- 5년: < 30초

---

## CI/CD 통합

### GitHub Actions 워크플로우

```yaml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 9 * * 1'  # 매주 월요일 오전 9시 (실제 API 테스트)

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-java@v3
        with:
          java-version: '21'
      - name: Run unit tests
        run: ./gradlew test --tests '*Test'

  integration-tests:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'push'
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-java@v3
        with:
          java-version: '21'
      - name: Run integration tests
        run: ./gradlew test --tests '*IntegrationTest'

  coverage:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-java@v3
        with:
          java-version: '21'
      - name: Generate coverage report
        run: ./gradlew jacocoTestReport
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
```

---

## 공매도 엔드포인트 테스트

### 공매도 거래 통합 테스트

**파일**: `/app/src/test/kotlin/com/kairos/krx/integration/ShortSellingIntegrationTest.kt`

```kotlin
package com.kairos.krx.integration

import com.kairos.krx.shortselling.ShortSellingService
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.DisplayName
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import java.time.LocalDate

@SpringBootTest
@DisplayName("공매도 통합 테스트")
class ShortSellingIntegrationTest {

    @Autowired
    private lateinit var service: ShortSellingService

    @Test
    @DisplayName("개별종목 공매도 거래 조회")
    fun `삼성전자 공매도 거래 데이터 조회 성공`() {
        // Given
        val ticker = "005930"  // 삼성전자
        val from = LocalDate.of(2024, 1, 2)
        val to = LocalDate.of(2024, 1, 31)

        // When
        val txns = service.getShortSellingTransactions(ticker, from, to)

        // Then
        assertTrue(txns.isNotEmpty(), "공매도 거래 데이터 존재")

        txns.forEach { txn ->
            // 기본 필드 검증
            assertNotNull(txn.date)
            assertNotNull(txn.name)

            // 거래량 검증
            assertTrue(txn.shortSellingVolume >= 0, "공매도 거래량 >= 0")
            assertTrue(txn.totalVolume >= txn.shortSellingVolume, "총거래량 >= 공매도거래량")

            // 비중 검증
            assertTrue(txn.volumeRatio >= BigDecimal.ZERO, "거래량 비중 >= 0")
            assertTrue(txn.volumeRatio <= BigDecimal("100.0000"), "거래량 비중 <= 100")
            assertTrue(txn.valueRatio >= BigDecimal.ZERO, "거래대금 비중 >= 0")
            assertTrue(txn.valueRatio <= BigDecimal("100.0000"), "거래대금 비중 <= 100")
        }
    }

    @Test
    @DisplayName("개별종목 공매도 종합정보 조회")
    fun `삼성전자 공매도 잔고 데이터 조회 성공`() {
        // Given
        val ticker = "005930"
        val from = LocalDate.of(2024, 1, 2)
        val to = LocalDate.of(2024, 1, 31)

        // When
        val balances = service.getShortSellingBalance(ticker, from, to)

        // Then
        assertTrue(balances.isNotEmpty(), "공매도 잔고 데이터 존재")

        balances.forEach { balance ->
            // 기본 필드 검증
            assertNotNull(balance.date)
            assertNotNull(balance.name)

            // 거래량 검증
            assertTrue(balance.shortSellingVolume >= 0, "공매도 거래량 >= 0")
            assertTrue(balance.repaymentVolume >= 0, "상환 거래량 >= 0")

            // 잔고 검증
            assertTrue(balance.balanceQuantity >= 0L, "공매도 잔고 >= 0")
            assertTrue(balance.balanceRatio >= BigDecimal.ZERO, "잔고 비율 >= 0")
            assertTrue(balance.listedShares > 0L, "상장주식수 > 0")
        }
    }

    @Test
    @DisplayName("높은 공매도 비중 종목 필터링")
    fun `공매도 비중 15% 이상 종목 필터링`() {
        // Given
        val tickers = listOf("005930", "000660", "035720")  // 삼성전자, SK하이닉스, 카카오
        val date = LocalDate.of(2024, 1, 31)
        val minRatio = BigDecimal("15.0000")

        // When
        val highShortStocks = service.getHighShortSellingRatioStocks(
            tickers = tickers,
            date = date,
            minRatio = minRatio
        )

        // Then
        highShortStocks.forEach { stock ->
            assertTrue(stock.volumeRatio >= minRatio, "${stock.name} 공매도 비중: ${stock.volumeRatio}%")
        }
    }

    @Test
    @DisplayName("높은 잔고 비율 종목 필터링")
    fun `잔고 비율 1% 이상 종목 필터링`() {
        // Given
        val tickers = listOf("005930", "000660", "035720")
        val date = LocalDate.of(2024, 1, 31)
        val minBalanceRatio = BigDecimal("1.0000")

        // When
        val highBalanceStocks = service.getHighBalanceRatioStocks(
            tickers = tickers,
            date = date,
            minBalanceRatio = minBalanceRatio
        )

        // Then
        highBalanceStocks.forEach { stock ->
            assertTrue(
                stock.balanceRatio >= minBalanceRatio,
                "${stock.name} 잔고 비율: ${stock.balanceRatio}%"
            )
        }
    }

    @Test
    @DisplayName("공매도 순거래량 계산 검증")
    fun `공매도 순거래량은 공매도 - 상환`() {
        // Given
        val ticker = "005930"
        val date = LocalDate.of(2024, 1, 31)

        // When
        val balances = service.getShortSellingBalance(ticker, date, date)

        // Then
        assertTrue(balances.isNotEmpty())
        balances.forEach { balance ->
            val expected = balance.shortSellingVolume - balance.repaymentVolume
            assertEquals(
                expected,
                balance.netShortSellingVolume,
                "순거래량 = 공매도 - 상환"
            )
        }
    }

    @Test
    @DisplayName("공매도 없는 종목 처리")
    fun `공매도가 없는 날짜는 빈 결과 또는 0 반환`() {
        // Given - 공매도가 없을 것으로 예상되는 날짜 (과거 또는 휴일)
        val ticker = "005930"
        val holiday = LocalDate.of(2024, 1, 1)  // 신정

        // When
        val txns = service.getShortSellingTransactions(ticker, holiday, holiday)

        // Then
        // 휴일은 데이터가 없거나 공매도가 0
        if (txns.isNotEmpty()) {
            txns.forEach { txn ->
                assertTrue(txn.shortSellingVolume == 0L || txn.totalVolume == 0L)
            }
        }
    }
}
```

---

### 공매도 엣지 케이스

```kotlin
@Test
fun `공매도 비중 100% 초과 방지`() {
    val txns = service.getShortSellingTransactions(
        ticker = "005930",
        from = LocalDate.now().minusMonths(1),
        to = LocalDate.now()
    )

    txns.forEach { txn ->
        assertTrue(txn.volumeRatio <= BigDecimal("100.0000"), "공매도 비중은 100% 이하")
        assertTrue(txn.valueRatio <= BigDecimal("100.0000"), "공매도 대금 비중은 100% 이하")
    }
}

@Test
fun `잔고 비율 음수 방지`() {
    val balances = service.getShortSellingBalance(
        ticker = "005930",
        from = LocalDate.now().minusMonths(1),
        to = LocalDate.now()
    )

    balances.forEach { balance ->
        assertTrue(balance.balanceRatio >= BigDecimal.ZERO, "잔고 비율은 0 이상")
        assertTrue(balance.balanceQuantity >= 0L, "잔고 수량은 0 이상")
    }
}
```

---

## MDCSTAT04701 전용 테스트 시나리오

### 시나리오 1: 완전성 검증

```kotlin
@Test
fun `MDCSTAT04701 모든 필드 존재 확인`() {
    val info = service.getComprehensiveInfo("069500", LocalDate.of(2024, 1, 2))

    assertNotNull(info)
    info!!.let {
        // 기본 식별 (5개)
        assertNotNull(it.tradeDate)
        assertNotNull(it.isin)
        assertNotNull(it.ticker)
        assertNotNull(it.name)
        assertNotNull(it.fullName)

        // OHLCV (8개)
        assertTrue(it.openPrice >= BigDecimal.ZERO)
        assertTrue(it.highPrice >= BigDecimal.ZERO)
        assertTrue(it.lowPrice >= BigDecimal.ZERO)
        assertTrue(it.closePrice >= BigDecimal.ZERO)

        // 52주 고저 (4개) - 핵심
        assertTrue(it.week52High > BigDecimal.ZERO)
        assertTrue(it.week52Low > BigDecimal.ZERO)
        assertNotNull(it.week52HighDate)
        assertNotNull(it.week52LowDate)

        // 보수 (핵심)
        assertTrue(it.totalFee >= BigDecimal.ZERO)
    }
}
```

---

### 시나리오 2: 다른 엔드포인트와 비교

```kotlin
@Test
fun `MDCSTAT04701 vs MDCSTAT04501 출력 비교`() {
    val date = LocalDate.of(2024, 1, 2)

    // 04701 (종합 정보)
    val comprehensive = comprehensiveService.getComprehensiveInfo("069500", date)

    // 04501 (OHLCV)
    val ohlcv = etfService.getOhlcv("069500", date, date).first()

    // OHLCV 데이터 일치 확인
    assertEquals(comprehensive!!.openPrice, ohlcv.open)
    assertEquals(comprehensive.highPrice, ohlcv.high)
    assertEquals(comprehensive.lowPrice, ohlcv.low)
    assertEquals(comprehensive.closePrice, ohlcv.close)
    assertEquals(comprehensive.volume, ohlcv.volume)
    assertEquals(comprehensive.nav, ohlcv.nav)
}
```

---

## 요약

### 테스트 커버리지 목표

| 계층 | 목표 커버리지 | 핵심 테스트 |
|------|--------------|------------|
| **단위 테스트** | > 85% | 정규화 함수, 모델, 서비스 로직 |
| **통합 테스트** | > 70% | 실제 KRX API 호출 |
| **E2E 테스트** | 선택적 | 전체 워크플로우 |

### 핵심 테스트 포인트

1. **정규화 함수**: 모든 엣지 케이스
2. **MDCSTAT04701**: 완전한 필드 검증
3. **공매도 엔드포인트**: 거래 및 잔고 데이터 검증
4. **역사적 데이터**: 730일 자동 분할
5. **엣지 케이스**: 휴일, 신규 상장, 특수 값
6. **성능**: 응답 시간 목표 달성

### 다음 단계

1. **Phase 1**: 정규화 함수 단위 테스트 작성
2. **Phase 2**: MDCSTAT04701 통합 테스트 작성
3. **Phase 3**: 성능 테스트 실행 및 최적화
4. **Phase 4**: CI/CD 파이프라인 구축

---

## 참조

- 01-프로젝트-개요.md: 아키텍처
- 03-MDCSTAT04701-상세명세.md: ComprehensiveEtfInfo 구현
- 04-데이터-매핑-명세.md: 정규화 규칙
- 05-구현-로드맵.md: 테스트 단계
- 06-API-설계.md: 테스트할 API
- **10-함수-시그니처-카탈로그.md**: 모든 함수의 완전한 시그니처 및 파라미터 제약사항
- **11-테스트-시나리오-명세.md**: 함수별 상세 테스트 시나리오 (Given-When-Then 형식)
