# 테스트 작성 원칙

> **목적**: kotlin-krx 프로젝트의 테스트 작성 표준 및 가이드라인
> **작성일**: 2025-01-19
> **버전**: v1.0
> **기반**: 업계 표준 기반, 프로젝트 고유 규칙 명시

---

## 목차

1. [핵심 원칙](#1-핵심-원칙)
2. [테스트 구조](#2-테스트-구조)
3. [테스트 명명 규칙](#3-테스트-명명-규칙)
4. [Test Doubles 전략](#4-test-doubles-전략)
5. [데이터베이스 테스트 전략](#5-데이터베이스-테스트-전략)
6. [테스트 조직화](#6-테스트-조직화)
7. [테스트 데이터 관리](#7-테스트-데이터-관리)
8. [테스트 분류](#8-테스트-분류)
9. [품질 기준](#9-품질-기준)

---

## 1. 핵심 원칙

### 1.1 4대 원칙

| 원칙 | 설명 | 예시 |
|-----|------|------|
| **Simplicity** | 가능한 한 단순하게 | 복잡한 Setup보다 명시적 데이터 생성 |
| **Test as Spec** | 테스트 = 실행 가능한 스펙 | 테스트 이름만으로 동작 이해 가능 |
| **Isolation** | 각 테스트는 독립적 | 테스트 간 순서 의존성 없음 |
| **Explicit Dependency** | 모든 의존성은 명시적 | 암묵적 상태/전역 변수 사용 금지 |

### 1.2 예시

```kotlin
// ✅ 좋은 예: 단순하고 명시적
@Test
fun `getEtfList should return all ETFs`() {
    // === arrange ===
    val api = KrxEtfApiImpl(httpClient)

    // === act ===
    val result = api.getEtfList()

    // === assert ===
    assertThat(result).isNotEmpty()
    assertThat(result.first().isin).hasSize(12)
}

// ❌ 나쁜 예: 암묵적 의존성, 복잡한 setup
lateinit var globalApi: KrxEtfApi
lateinit var cachedResult: List<EtfListItem>

@BeforeEach
fun setup() {
    globalApi = createComplexSetup()
    cachedResult = globalApi.getEtfList() // 전역 상태
}

@Test
fun `test something`() {
    // cachedResult에 의존 (암묵적)
}
```

---

## 2. 테스트 구조

### 2.1 AAA 패턴 (Arrange-Act-Assert)

**모든 테스트는 AAA 패턴을 따릅니다:**

```kotlin
@Test
fun `test_name`() {
    // === Arrange: [비즈니스 컨텍스트] ===
    // 테스트 대상 준비
    val sut = SystemUnderTest()
    val input = TestData()

    // === Act: [수행 동작] ===
    // 실제 동작 실행
    val result = sut.doSomething(input)

    // === Assert: [예상 결과] ===
    // 결과 검증
    assertThat(result).isEqualTo(expected)
}
```

### 2.2 주석 규칙

**주석은 "왜(Why)"가 중요한 경우만 추가:**

```kotlin
// ✅ 좋은 예: 복잡한 비즈니스 규칙 설명
@Test
fun `calculateAdjustedPrice should apply split ratio before dividends`() {
    // === arrange ===
    // 배당락일과 분할일이 겹칠 때는 분할 비율을 먼저 적용해야 함
    // (금융 업계 표준: CRSP 방식)
    val splitDate = LocalDate.of(2024, 1, 15)
    val dividendDate = LocalDate.of(2024, 1, 15)
    val splitRatio = BigDecimal("2.0")
    val dividendAmount = BigDecimal("100")

    // === act ===
    val result = calculator.calculate(splitDate, dividendDate, splitRatio, dividendAmount)

    // === assert ===
    assertThat(result).isEqualTo(expected)
}

// ❌ 나쁜 예: 자명한 내용 주석
@Test
fun `getEtfList should return list`() {
    // 리스트를 가져옴
    val result = api.getEtfList()

    // 리스트가 비어있지 않음을 확인
    assertThat(result).isNotEmpty()
}
```

**주석이 필요한 경우:**
- 복잡한 비즈니스 규칙
- 여러 단계 시나리오
- 도메인 불변식 (Domain Invariant)
- 외부 표준 준수 (예: ISO, CRSP 방식)

---

## 3. 테스트 명명 규칙

### 3.1 형식

**Format**: `{action}_{context}_{expected}`

**언어**: Kotlin 관례 (backtick + 자연어)

```kotlin
// ✅ 좋은 예
@Test
fun `getEtfList should return all ETFs when data exists`()

@Test
fun `getEtfOhlcv should split date range when exceeds 730 days`()

@Test
fun `getDividendInfo should throw NoDataException when corp code not found`()

// ❌ 나쁜 예 (모호함)
@Test
fun `test1`()

@Test
fun `getEtfList`()

@Test
fun `testGetEtfListSuccess`()
```

### 3.2 네이밍 가이드

| 패턴 | 예시 |
|-----|------|
| 정상 동작 | `should return X when Y` |
| 예외 상황 | `should throw XException when Y` |
| 경계 조건 | `should handle empty list` |
| 비즈니스 규칙 | `should apply split ratio before dividends` |
| 데이터 변환 | `should convert raw JSON to EtfListItem` |

---

## 4. Test Doubles 전략

### 4.1 원칙: Fake 우선, Mock 최소화

**Fake**: 실제 인터페이스의 완전한 구현체 (In-memory)
**Mock**: 호출 검증용, 최후의 수단

### 4.2 Fake 사용

**정의**: 실제 동작하는 구현체, 상태 검증 가능

**사용 시점**:
- 외부 API Client (KRX, Naver, OPENDART)
- 비즈니스 로직 테스트 시 Repository
- 복잡한 데이터 시나리오 제어 필요 시

**특징**:
- 완전한 인터페이스 구현
- In-memory 상태 관리
- 예측 가능한 동작
- 테스트 시나리오 제어 용이

**예시**:

```kotlin
// Fake Repository 구현
class FakeEtfRepository : EtfRepository {
    private val etfs = mutableMapOf<String, EtfListItem>()

    override suspend fun findAll(): List<EtfListItem> {
        return etfs.values.toList()
    }

    override suspend fun findByIsin(isin: String): EtfListItem? {
        return etfs[isin]
    }

    override suspend fun save(etf: EtfListItem) {
        etfs[etf.isin] = etf
    }

    // 테스트 헬퍼 (프로덕션 인터페이스에 없음)
    fun clear() {
        etfs.clear()
    }

    fun count(): Int {
        return etfs.size
    }
}

// 사용 예시
@Test
fun `collectEtfData should save new ETFs to repository`() {
    // === arrange ===
    val fakeRepo = FakeEtfRepository()
    val fakeApi = FakeKrxEtfApi().apply {
        addEtf(EtfMother.kodex200())
        addEtf(EtfMother.tiger200())
    }
    val collector = EtfDataCollector(fakeApi, fakeRepo)

    // === act ===
    collector.collect()

    // === assert ===
    assertThat(fakeRepo.count()).isEqualTo(2)
    assertThat(fakeRepo.findByIsin("KR7069500007")).isNotNull()
}
```

### 4.3 Mock 사용

**원칙**: 최후의 수단, Fake 구현이 불가능할 때만

**사용 시점**:
- 호출 여부만 검증 (이벤트 발행 등)
- 시간/랜덤 제어 (TimeProvider)
- 강제 오류 시뮬레이션

**주의**: Mock 사용 시 주석으로 사유 명시 필수

```kotlin
// ✅ 적절한 Mock 사용: 호출 검증
@Test
fun `publishEvent should notify subscribers`() {
    // Mock 사용 이유: 이벤트 발행 여부만 검증, 상태 검증 불필요
    val eventPublisher = mockk<EventPublisher>()
    val service = EtfService(eventPublisher)

    // === act ===
    service.updateEtf(etf)

    // === assert ===
    verify { eventPublisher.publish(any<EtfUpdatedEvent>()) }
}

// ✅ 적절한 Mock 사용: 시간 제어
@Test
fun `isMarketOpen should return false outside trading hours`() {
    // Mock 사용 이유: 시간 제어 필요
    val timeProvider = mockk<TimeProvider>()
    every { timeProvider.now() } returns LocalTime.of(8, 0) // 장 시작 전

    val service = MarketService(timeProvider)

    // === act ===
    val result = service.isMarketOpen()

    // === assert ===
    assertThat(result).isFalse()
}
```

### 4.4 Repository 전략

**기본 원칙**: FakeRepository 사용 (비즈니스 로직 검증)

**실제 DB 사용 시점**:
- Repository CRUD 자체 검증
- DB 제약조건 검증 (FK, Unique, Check)
- 트랜잭션 동작 검증
- 동시성 이슈 검증 (Race Condition)
- 복잡한 쿼리 성능 검증

**Note**: 검증 목적에 따라 Fake/Real 선택 - 레이어 개수는 무관

```kotlin
// ✅ 비즈니스 로직 검증: FakeRepository
@Test
fun `update ETF price should recalculate NAV`() {
    val fakeRepo = FakeEtfRepository()
    val service = EtfService(fakeRepo)

    // 비즈니스 로직 검증
}

// ✅ DB 제약조건 검증: Real DB
@Test
fun `save should throw exception when ISIN violates unique constraint`() {
    val realRepo = RealEtfRepository(testDatabase)

    // === arrange ===
    val etf1 = EtfMother.kodex200()
    realRepo.save(etf1)

    // === act & assert ===
    val etf2 = etf1.copy(name = "Different Name")
    assertThrows<UniqueConstraintException> {
        realRepo.save(etf2) // 같은 ISIN
    }
}
```

---

## 5. 데이터베이스 테스트 전략

### 5.1 Testcontainers 사용

**엔진**: Testcontainers PostgreSQL

**이유**:
- Production과 동일한 DB 엔진
- 완전한 격리 환경
- Migration 적용 가능

```kotlin
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class EtfRepositoryTest {
    private lateinit var container: PostgreSQLContainer<Nothing>
    private lateinit var dataSource: DataSource

    @BeforeAll
    fun startContainer() {
        container = PostgreSQLContainer<Nothing>("postgres:16").apply {
            withDatabaseName("testdb")
            withUsername("test")
            withPassword("test")
            start()
        }

        dataSource = HikariDataSource(HikariConfig().apply {
            jdbcUrl = container.jdbcUrl
            username = container.username
            password = container.password
        })

        // Migration 적용
        Flyway.configure()
            .dataSource(dataSource)
            .load()
            .migrate()
    }

    @AfterAll
    fun stopContainer() {
        container.stop()
    }
}
```

### 5.2 테스트 격리 전략

**방법**: 고유 데이터 생성 (UUID, timestamp)

**Cleanup**: 테스트 후 데이터 유지 (디버깅 용이)

```kotlin
@Test
fun `test with unique data`() {
    // === arrange ===
    // 고유 ISIN 생성 (테스트 격리)
    val isin = "KR7${UUID.randomUUID().toString().take(6)}007"
    val etf = EtfListItem(
        isin = isin,
        ticker = "TEST${System.currentTimeMillis()}",
        name = "Test ETF ${UUID.randomUUID()}"
    )

    // 다른 테스트와 충돌 없음
    repository.save(etf)

    // === act & assert ===
    val found = repository.findByIsin(isin)
    assertThat(found).isEqualTo(etf)
}
```

**장점**:
- 테스트 간 완전 격리
- 병렬 실행 가능
- Rollback 불필요 (디버깅 용이)

**단점**:
- 데이터 축적 (CI 환경에서는 컨테이너 재시작으로 해결)

---

## 6. 테스트 조직화

### 6.1 Fixture Pattern: `{Domain}Mother`

**목적**: 반복 setup 공유 Fixture로 추출

**메서드 규칙**:
- `simple()`: 최소 필수 데이터
- `complete()`: 모든 필드 완성
- `with{State}()`: 특정 상태 설정

```kotlin
object EtfMother {
    fun simple(): EtfListItem {
        return EtfListItem(
            isin = "KR7069500007",
            ticker = "069500",
            name = "KODEX 200",
            listingDate = LocalDate.of(2002, 10, 14),
            totalExpenseRatio = BigDecimal("0.15")
        )
    }

    fun complete(): EtfListItem {
        return simple().copy(
            assetClass = "Equity",
            nav = BigDecimal("42965"),
            closePrice = 42965,
            totalAssets = 5_000_000_000_000L
        )
    }

    fun withMarket(market: String): EtfListItem {
        return simple().copy(marketType = market)
    }

    fun withPrice(price: Int): EtfListItem {
        return simple().copy(closePrice = price)
    }
}

// 사용 예시
@Test
fun `test with fixture`() {
    // === arrange ===
    val etf = EtfMother.simple()
        .withMarket("KRX")
        .withPrice(50000)

    // === act & assert ===
    // ...
}
```

### 6.2 Builder Pattern (선택)

**복잡한 객체 생성 시 Builder 사용 가능:**

```kotlin
class EtfBuilder {
    private var isin: String = "KR7069500007"
    private var ticker: String = "069500"
    private var name: String = "KODEX 200"
    private var listingDate: LocalDate = LocalDate.of(2002, 10, 14)
    private var totalExpenseRatio: BigDecimal = BigDecimal("0.15")

    fun withIsin(isin: String) = apply { this.isin = isin }
    fun withTicker(ticker: String) = apply { this.ticker = ticker }
    fun withName(name: String) = apply { this.name = name }

    fun build(): EtfListItem {
        return EtfListItem(
            isin = isin,
            ticker = ticker,
            name = name,
            listingDate = listingDate,
            totalExpenseRatio = totalExpenseRatio
        )
    }
}

// 사용
val etf = EtfBuilder()
    .withIsin("KR7123456789")
    .withTicker("123456")
    .withName("Custom ETF")
    .build()
```

---

## 7. 테스트 데이터 관리

### 7.1 고유성 보장 방법

**3가지 전략**:

1. **UUID 기반**:
```kotlin
val isin = "KR7${UUID.randomUUID().toString().take(6)}007"
```

2. **Timestamp 기반**:
```kotlin
val ticker = "TEST${System.currentTimeMillis()}"
```

3. **Atomic Counter**:
```kotlin
object TestIdGenerator {
    private val counter = AtomicInteger(0)

    fun nextIsin(): String {
        return "KR7%06d007".format(counter.incrementAndGet())
    }
}
```

### 7.2 테스트 데이터 파일

**위치**: `src/test/resources/test-data/`

**형식**: JSON (가독성), Parquet (성능)

```
src/test/resources/test-data/
├── krx/
│   ├── etf-list-response.json
│   ├── etf-ohlcv-response.json
│   └── etf-detail-response.json
├── naver/
│   └── adjusted-close-response.txt
└── opendart/
    └── corp-code-response.xml
```

**로딩 예시**:
```kotlin
fun loadTestData(filename: String): String {
    return this::class.java
        .getResourceAsStream("/test-data/$filename")!!
        .bufferedReader()
        .readText()
}

@Test
fun `parse KRX ETF list response`() {
    // === arrange ===
    val json = loadTestData("krx/etf-list-response.json")
    val parser = KrxEtfDataParser()

    // === act ===
    val result = parser.parse(json)

    // === assert ===
    assertThat(result).hasSize(10)
}
```

---

## 8. 테스트 분류

### 8.1 비즈니스 테스트

**Format**: `TC-XXX: [설명]`

**목적**: Event Storming 시나리오와 매핑

```kotlin
@Test
@DisplayName("TC-001: ETF 목록 조회 성공")
fun `getEtfList should return all ETFs when data exists`() {
    // Event Storming: "ETF 목록이 조회됨" 이벤트
}

@Test
@DisplayName("TC-002: 730일 초과 시 자동 분할")
fun `getEtfOhlcv should split date range when exceeds 730 days`() {
    // Event Storming: "날짜 범위가 자동으로 분할됨" 이벤트
}
```

### 8.2 기술 테스트

**Format**: `[설명] (기술적)`

**목적**: 기술적 검증 명시

```kotlin
@Test
@DisplayName("JSON 파싱 성공 (기술적)")
fun `parse should convert JSON to EtfListItem`() {
    // 기술적 검증: JSON 파싱 로직
}

@Test
@DisplayName("타입 변환 성공 (기술적)")
fun `toKrxInt should remove comma and convert to int`() {
    // 기술적 검증: 타입 변환 로직
}
```

---

## 9. 품질 기준

### 9.1 피해야 할 것

**Anti-patterns**:

| 안티패턴 | 설명 | 대안 |
|---------|------|------|
| 과도한 Mock | Mock으로 모든 의존성 대체 | Fake 구현 사용 |
| 긴 테스트 메서드 | 50줄 이상 | 헬퍼 메서드로 분리 |
| 하드코딩된 ID | 고정된 ID/타임스탬프 | UUID, Timestamp 사용 |
| 테스트 순서 의존 | `@TestMethodOrder` 사용 | 각 테스트 독립적 실행 |
| 암묵적 Setup | `@BeforeEach`에 복잡한 로직 | Fixture/Mother 패턴 |

### 9.2 코드 예시

```kotlin
// ❌ 나쁜 예: 과도한 Mock, 긴 테스트, 하드코딩
@Test
fun `complex test`() {
    val mockRepo = mockk<EtfRepository>()
    val mockApi = mockk<KrxEtfApi>()
    val mockCache = mockk<CacheManager>()
    val mockLogger = mockk<Logger>()
    // ... 50줄의 mock setup ...

    every { mockRepo.findByIsin("KR7069500007") } returns etf // 하드코딩
    every { mockApi.getEtfList() } returns listOf(etf)
    // ... 더 많은 setup ...

    // === act ===
    val result = service.doSomething()

    // === assert ===
    verify { mockRepo.save(any()) }
    verify { mockApi.getEtfList() }
    // ... 많은 verify ...
}

// ✅ 좋은 예: Fake 사용, 간결한 테스트, 동적 데이터
@Test
fun `doSomething should save ETF to repository`() {
    // === arrange ===
    val fakeRepo = FakeEtfRepository()
    val fakeApi = FakeKrxEtfApi().apply {
        addEtf(EtfMother.simple())
    }
    val service = EtfService(fakeApi, fakeRepo)

    // === act ===
    service.doSomething()

    // === assert ===
    assertThat(fakeRepo.count()).isEqualTo(1)
}
```

### 9.3 테스트 커버리지 목표

| 레이어 | 목표 | 중요도 |
|--------|------|--------|
| API Layer | 100% | 높음 |
| Model Layer | 90%+ | 중간 |
| Internal Layer | 80%+ | 중간 |
| Exception | 100% | 높음 |

---

## 10. 체크리스트

### 10.1 테스트 작성 시

- [ ] AAA 패턴을 따르는가?
- [ ] 테스트 이름이 명확한가?
- [ ] Mock 대신 Fake를 사용했는가? (Mock 사용 시 주석 있는가?)
- [ ] 하드코딩된 ID/타임스탬프가 없는가?
- [ ] 테스트가 독립적으로 실행되는가?
- [ ] 50줄 이하인가?
- [ ] 복잡한 비즈니스 규칙에 주석이 있는가?

### 10.2 테스트 리뷰 시

- [ ] 테스트가 실제로 검증하려는 것을 검증하는가?
- [ ] 테스트가 실패할 때 명확한 오류 메시지를 제공하는가?
- [ ] 테스트가 빠르게 실행되는가? (단위 테스트 < 100ms)
- [ ] 테스트가 flaky하지 않은가? (10번 실행 시 10번 성공)

---

## 요약

### 핵심 원칙

1. **Fake > Mock**: 가능하면 Fake 구현, Mock은 최후의 수단
2. **AAA 패턴**: 모든 테스트는 Arrange-Act-Assert
3. **독립성**: 각 테스트는 독립적으로 실행 가능
4. **명시성**: 모든 의존성은 명시적으로 선언
5. **간결성**: 50줄 이하, 하나의 관심사만 테스트

### 권장 도구

- **Test Framework**: JUnit 5
- **Assertion**: AssertJ (유창한 API)
- **Mock (필요시)**: MockK
- **DB Testing**: Testcontainers PostgreSQL
- **Fixture**: Mother 패턴

### 참고 문서

- [07-테스트-전략.md](07-테스트-전략.md) - 전체 테스트 전략
- [11-테스트-시나리오-명세.md](./11-테스트-시나리오-명세.md) - KRX 테스트 시나리오
- [13-KRX-테스트-시나리오-명세.md](13-KRX-테스트-시나리오-명세.md) - KRX 상세 테스트

---

**작성일**: 2025-01-19
**버전**: v1.0
**작성자**: kotlin-krx (kfc) 프로젝트
